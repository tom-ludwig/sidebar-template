/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Health API
 * Health check endpoints for Kubernetes probes and monitoring.
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HealthResponse,
  ReadinessFailure
} from '.././models';

import { publicFetch } from '../../../fetchers/public';




/**
 * Returns a 200 status code.
 * @summary Get Health
 */
export const getHealthz = (
    
 signal?: AbortSignal
) => {
      
      
      return publicFetch<HealthResponse>(
      {url: `/healthz`, method: 'GET', signal
    },
      );
    }
  



export const getGetHealthzQueryKey = () => {
    return [
    `/healthz`
    ] as const;
    }

    
export const getGetHealthzQueryOptions = <TData = Awaited<ReturnType<typeof getHealthz>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHealthzQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthz>>> = ({ signal }) => getHealthz(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHealthzQueryResult = NonNullable<Awaited<ReturnType<typeof getHealthz>>>
export type GetHealthzQueryError = unknown


export function useGetHealthz<TData = Awaited<ReturnType<typeof getHealthz>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthz>>,
          TError,
          Awaited<ReturnType<typeof getHealthz>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthz<TData = Awaited<ReturnType<typeof getHealthz>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealthz>>,
          TError,
          Awaited<ReturnType<typeof getHealthz>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHealthz<TData = Awaited<ReturnType<typeof getHealthz>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Health
 */

export function useGetHealthz<TData = Awaited<ReturnType<typeof getHealthz>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthz>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHealthzQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Kubernetes uses this to determine if your container needs to be restarted. Should check if your application process is still running and responsive.
 * @summary Liveness Probe
 */
export const getLivez = (
    
 signal?: AbortSignal
) => {
      
      
      return publicFetch<HealthResponse>(
      {url: `/livez`, method: 'GET', signal
    },
      );
    }
  



export const getGetLivezQueryKey = () => {
    return [
    `/livez`
    ] as const;
    }

    
export const getGetLivezQueryOptions = <TData = Awaited<ReturnType<typeof getLivez>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLivezQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLivez>>> = ({ signal }) => getLivez(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLivezQueryResult = NonNullable<Awaited<ReturnType<typeof getLivez>>>
export type GetLivezQueryError = unknown


export function useGetLivez<TData = Awaited<ReturnType<typeof getLivez>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLivez>>,
          TError,
          Awaited<ReturnType<typeof getLivez>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLivez<TData = Awaited<ReturnType<typeof getLivez>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLivez>>,
          TError,
          Awaited<ReturnType<typeof getLivez>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLivez<TData = Awaited<ReturnType<typeof getLivez>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Liveness Probe
 */

export function useGetLivez<TData = Awaited<ReturnType<typeof getLivez>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLivez>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLivezQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Tells Kubernetes when your pod is ready to receive traffic. Should verify dependencies are available (database connections, external APIs, etc.). If this fails, Kubernetes removes the pod from service endpoints until it passes.
 * @summary Readiness Probe
 */
export const getReadyz = (
    
 signal?: AbortSignal
) => {
      
      
      return publicFetch<HealthResponse>(
      {url: `/readyz`, method: 'GET', signal
    },
      );
    }
  



export const getGetReadyzQueryKey = () => {
    return [
    `/readyz`
    ] as const;
    }

    
export const getGetReadyzQueryOptions = <TData = Awaited<ReturnType<typeof getReadyz>>, TError = ReadinessFailure>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReadyzQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReadyz>>> = ({ signal }) => getReadyz(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReadyzQueryResult = NonNullable<Awaited<ReturnType<typeof getReadyz>>>
export type GetReadyzQueryError = ReadinessFailure


export function useGetReadyz<TData = Awaited<ReturnType<typeof getReadyz>>, TError = ReadinessFailure>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReadyz>>,
          TError,
          Awaited<ReturnType<typeof getReadyz>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReadyz<TData = Awaited<ReturnType<typeof getReadyz>>, TError = ReadinessFailure>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReadyz>>,
          TError,
          Awaited<ReturnType<typeof getReadyz>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReadyz<TData = Awaited<ReturnType<typeof getReadyz>>, TError = ReadinessFailure>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Readiness Probe
 */

export function useGetReadyz<TData = Awaited<ReturnType<typeof getReadyz>>, TError = ReadinessFailure>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReadyz>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReadyzQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




